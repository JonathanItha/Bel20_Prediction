# -*- coding: utf-8 -*-
"""Bel20_pred.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mexaci5BOogRYsXqHjQsWMtPDyE_1KFX
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler

bel20 = yf.download('^BFX', end='2023-01-01')
print(bel20.head())
#bel20future = yf.download('^BFX', end='2022-01-01')
#bel20future_hist = yf.download('^BFX', end='2022-03-01')

print(bel20.describe())
print(bel20.info())

bel20['Close'].plot(figsize=(14, 7))
plt.title('BEL 20 Closing Prices')
plt.show()

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
print(tf.__version__)

bel20 = bel20['Close'].values
bel20 = bel20.reshape(-1, 1)

scaler = MinMaxScaler(feature_range=(0, 1))
bel20 = scaler.fit_transform(bel20)

x = []
y = []

for i in range(260, len(bel20)):
  x.append(bel20[i - 260:i, 0])
  y.append(bel20[i, 0]) #analyse the 260 last days

x = np.array(x)
y = np.array(y)

x = np.reshape(x, (x.shape[0], x.shape[1], 1))
#print(x)

model = Sequential()

model.add(LSTM(units=50, activation='relu', return_sequences=True, input_shape=(260, 1)))
model.add(Dropout(0.1))

model.add(LSTM(units=50, activation='relu',  return_sequences=False))
model.add(Dropout(0.2))

model.add(Dense(units=25))
model.add(Dense(units=1))

#model.add(LSTM(units=40, activation='relu', return_sequences=True))
#model.add(Dropout(0.1))

#model.add(LSTM(units=50, activation='relu', return_sequences=True))
#model.add(Dropout(0.1))

#model.add(LSTM(units=60, activation='relu'))
#model.add(Dropout(0.1))

#model.add(Dense(units=1))

model.compile(optimizer='adam', loss='mean_squared_error')

split = int(0.98 * len(x))
x_train, x_test = x[:split], x[split:]
y_train, y_test = y[:split], y[split:]

early_stopping = EarlyStopping(monitor='loss', patience=3, restore_best_weights=True)

.+-model.fit(x_train, y_train, epochs=50, batch_size=32, callbacks=[early_stopping])

predictions = model.predict(x_test)

predictions = scaler.inverse_transform(predictions)
actual_y_test = scaler.inverse_transform(y_test.reshape(-1, 1))
#print(predictions)
#print(actual_y_test)

plt.figure(figsize=(14, 7))
plt.plot(actual_y_test, color='blue', label='Actual BEL 20 Price')
plt.plot(predictions, color='red', label='Predicted BEL 20 Trend' ,  linestyle='dashed', markersize=4)
plt.title('BEL 20 Trend Prediction')
plt.xlabel('Predicted days')
plt.ylabel('Price')
plt.legend()
plt.show()

actual_prices = np.array(actual_y_test)
predicted_prices = np.array(predictions)
absolute_differences = np.abs(actual_prices - predicted_prices)
A = np.mean(absolute_differences)
print(absolute_differences.max())
print(absolute_differences.min())
print(f"The average of the absolute differences (A) is: {A}")

"""Now I will create function to direclty analyse the composition of the bel20"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
import tensorflow as tf

#dowload stock
def download_stock_data(ticker, end_date):

    return yf.download(ticker, end=end_date)
#prepocesss
def preprocess_data(data, sequence_length):

    data = data['Close'].values.reshape(-1, 1)
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(data)

    x, y = [], []
    for i in range(sequence_length, len(scaled_data)):
        x.append(scaled_data[i - sequence_length:i, 0])
        y.append(scaled_data[i, 0])

    x, y = np.array(x), np.array(y)
    x = np.reshape(x, (x.shape[0], x.shape[1], 1))

    return x, y, scaler
#LSTM Model
def build_and_train_model(x_train, y_train, sequence_length):
    model = Sequential([
        LSTM(units=50, activation='relu', return_sequences=True, input_shape=(sequence_length, 1)),
        Dropout(0.1),
        LSTM(units=50, activation='relu', return_sequences=False),
        Dropout(0.2),
        Dense(units=25),
        Dense(units=1)
    ])

    model.compile(optimizer='adam', loss='mean_squared_error')
    early_stopping = EarlyStopping(monitor='loss', patience=3, restore_best_weights=True)

    model.fit(x_train, y_train, epochs=50, batch_size=32, callbacks=[early_stopping])

    return model
#Prediction
def make_predictions(model, x_test, scaler):

    predictions = model.predict(x_test)
    predictions = scaler.inverse_transform(predictions)

    return predictions
#Plot
def plot_results(actual_y_test, predictions):

    plt.figure(figsize=(14, 7))
    plt.plot(actual_y_test, color='blue', label='Actual Price')
    plt.plot(predictions, color='red', label='Predicted Price', linestyle='dashed', markersize=4)
    plt.title('Stock Price Prediction')
    plt.xlabel('Predicted Day')
    plt.ylabel('Price')
    plt.legend()
    plt.show()
#Perf metric
def evaluate_performance(actual_y_test, predictions):

    absolute_differences = np.abs(actual_y_test - predictions)
    max_error = absolute_differences.max()
    min_error = absolute_differences.min()
    mean_error = np.mean(absolute_differences)

    print(f"Max error: {max_error}")
    print(f"Min error: {min_error}")
    print(f"Mean error: {mean_error}")

#Fct to run
def main(ticker, end_date, sequence_length=260):

    data = download_stock_data(ticker, end_date)

    x, y, scaler = preprocess_data(data, sequence_length)

    split = int(0.98 * len(x))
    x_train, x_test = x[:split], x[split:]
    y_train, y_test = y[:split], y[split:]

    model = build_and_train_model(x_train, y_train, sequence_length)

    predictions = make_predictions(model, x_test, scaler)
    actual_y_test = scaler.inverse_transform(y_test.reshape(-1, 1))

    plot_results(actual_y_test, predictions)

    evaluate_performance(actual_y_test, predictions)

# Example of using the main function
if __name__ == "__main__":
    main('AGS.BR', '2023-01-01')

if __name__ == "__main__":
    main('UCB.BR', '2023-01-01')
